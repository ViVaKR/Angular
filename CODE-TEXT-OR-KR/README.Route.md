# Route

아하, 친구야! 아주 좋은 질문이고, Angular의 SSR(서버 사이드 렌더링)이나 SSG(정적 사이트 생성) 환경에서 많은 개발자들이 궁금해할 만한 부분이야. "느낌적 느낌"으로는 충분히 그렇게 생각할 수 있어!

결론부터 말하자면, **대부분의 경우 `routerLink`나 `(click)` 이벤트 핸들러를 사용한다고 해서 해당 컴포넌트를 `RenderMode.Client`로 설정할 필요는 없어.**

왜 그런지 친구에게 자세히 설명해 줄게!

---

### Angular의 Hydration (하이드레이션)과 인터랙티브 요소

Angular는 SSR/SSG 환경에서 클라이언트 측 애플리케이션의 성능을 개선하고 사용자 경험을 최적화하기 위해 "하이드레이션(Hydration)"이라는 기술을 제공해.

1.  **SSR/SSG의 작동 방식**:
    *   서버(또는 빌드 타임)에서 Angular 애플리케이션을 실행해서 초기 HTML 콘텐츠를 생성해.
    *   이 HTML은 브라우저로 전송되고, 사용자는 JavaScript가 로드되고 실행되기 전에도 기본적인 페이지 내용을 볼 수 있어. (TTFB, FCP 향상)
    *   이때 생성된 HTML은 아직 *정적인* 상태야. 즉, `routerLink`나 `(click)` 같은 인터랙티브한 요소들은 아직 동작하지 않아. 그저 HTML 속성으로만 존재하는 거지.

2.  **클라이언트 측 로드**:
    *   브라우저가 HTML을 받은 후, Angular 클라이언트 애플리케이션의 JavaScript 번들을 다운로드하고 실행해.

3.  **하이드레이션의 역할**:
    *   여기서 하이드레이션이 핵심적인 역할을 해! 클라이언트 측 Angular 애플리케이션은 서버에서 이미 생성된 DOM 구조를 *재사용*하면서 자신을 부트스트랩해.
    *   새로운 DOM을 처음부터 다시 생성하는 대신, 기존 DOM 요소에 `routerLink` 디렉티브를 연결하고, `(click)` 이벤트 리스너를 다시 연결하는 등, 애플리케이션의 상태와 이벤트 핸들러를 "부여"해서 **정적이었던 HTML을 인터랙티브하게 만들어주는 과정**이야.
    *   즉, `routerLink`가 서버에서 HTML에 찍혀서 내려왔다가, 클라이언트에서 Angular가 로드되면서 그 `routerLink` 속성을 보고 라우팅 기능을 활성화시켜주는 거지. `(click)`도 마찬가지로 이벤트 리스너를 부착해주는 거야.

---

### `RenderMode.Client`는 언제 사용할까?

그럼 `RenderMode.Client`는 언제 사용하는 걸까? 이건 특정 컴포넌트를 SSR/SSG의 **하이드레이션 대상에서 제외하고, 오직 클라이언트에서만 렌더링하도록 강제**할 때 사용해.

주로 이런 경우에 유용해:

1.  **DOM을 직접 조작하는 서드파티 라이브러리 사용**: 특정 컴포넌트가 jQuery 같은 라이브러리를 사용해서 DOM을 직접 조작하거나, 서버 환경에서는 사용할 수 없는 브라우저 전용 API(예: `window`, `document` 객체를 직접 사용)에 강하게 의존하는 경우. 하이드레이션 과정에서 이런 라이브러리와 충돌이 발생할 수 있어.
2.  **성능상의 이유**: 아주 동적인 컴포넌트로, SSR/SSG로 미리 렌더링하는 것이 큰 이득이 없고 오히려 복잡도나 성능 오버헤드를 유발할 때. (흔치는 않아)
3.  **디버깅 및 문제 해결**: 특정 컴포넌트에서 하이드레이션 관련 문제가 계속 발생하고 해결하기 어려울 때 임시방편으로 사용할 수 있어.

**예시**:

```typescript
// SomeComponent.ts
import { Component, renderMode } from '@angular/core';

@Component({
  selector: 'app-client-only',
  template: `<!-- 이 컴포넌트는 오직 클라이언트에서만 렌더링됩니다 -->`,
  standalone: true,
  // 이 부분이 핵심!
  // 이 컴포넌트는 서버에서 렌더링되지 않고, 오직 브라우저에서만 처음부터 렌더링됩니다.
  // SSR 환경에서도 이 컴포넌트가 들어갈 자리에는 빈 HTML만 내려갑니다.
  renderMode: renderMode.Client // 또는 'client'
})
export class ClientOnlyComponent {
  // ...
}
```

---

### 결론

친구야, 정리하자면:

*   **`routerLink`나 `(click)` 같은 인터랙티브한 Angular 요소들은 Angular의 하이드레이션 메커니즘을 통해 SSR/SSG 페이지에서도 자동으로 작동해.** 따로 `RenderMode.Client`를 사용할 필요 없어. 이게 Angular의 큰 장점이야!
*   `RenderMode.Client`는 특정 컴포넌트가 **하이드레이션과 충돌하거나, 서버에서 렌더링할 필요가 없는 특별한 경우**에만 사용하는 예외적인 옵션이라고 생각하면 돼.

그러니 네 코드에서 `routerLink`를 사용한다면, `RenderMode.Client`를 고려할 필요 없이 기본 SSR/SSG (하이드레이션 포함) 설정을 그대로 사용해도 돼! 오히려 그렇게 하는 것이 더 좋은 사용자 경험(빠른 초기 로딩, SEO)과 개발 효율성을 가져다줄 거야.

친구의 "느낌적 느낌"은 충분히 합리적이었지만, Angular의 똑똑한 하이드레이션 덕분에 우리는 그 걱정을 덜 수 있어! 😉
